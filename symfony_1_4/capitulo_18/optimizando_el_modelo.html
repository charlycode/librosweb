<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <title>18.2. Optimizando el modelo (Symfony 1.4, la guía definitiva)</title>
        <link href="../../css/main-fa23fb7.css" rel="stylesheet" type="text/css" />
        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-82842-2']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
        <link rel="apple-touch-icon" type="image/png" href="../../apple-touch-icon.png" />
        <link rel="apple-touch-icon-precomposed" type="image/png" href="../../apple-touch-icon.png" />
        <meta name="apple-mobile-web-app-title" content="LibrosWeb" />

        <link rel="shortcut icon" type="image/png" href="../../favicon.png" />
        <meta name="site:version" content="fa23fb7" />
        <link rel="author" href="https://plus.google.com/u/0/107307901774377088868" />
        <link rel="prev" href="optimizando_el_servidor.html" />
        <link rel="next" href="optimizando_la_vista.html" />
        <link rel="start" href="../index.html" />
        <meta name="twitter:site" content="@librosweb" />
        <link rel="search" type="application/opensearchdescription+xml" href="http://librosweb.es/opensearch/documentation.xml" title="Libros y tutoriales de LibrosWeb.es" />
        <meta property="fb:page_id" content="437758756273955" />
        <meta property="fb:app_id" content="437758756273955" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="18.2. Optimizando el modelo (Symfony 1.4, la guía definitiva)" />
        <meta property="og:image" content="http://www.gravatar.com/avatar/9f219b4dfaa677bfd0f47753c02d5126.png?s=200" />
        <meta name="msapplication-TileColor" content="#CC1414" />
        <meta name="application-name" content="LibrosWeb" />
        <meta name="msapplication-tooltip" content="Libros y tutoriales sobre HTML, CSS, JavaScript, PHP y otras tecnologías web." />
    </head>
    <body class="book_page symfony_1_4">
    <div id="container" class="container">
        <div id="header">
            <h1><a href="../../index.html" title="LibrosWeb.es">LibrosWeb</a></h1>
            <form action="/buscar"><input type="text" placeholder="buscar..." name="q"/></form>
        </div>
        <div id="content"><div class="row">
        <ul class="breadcrumbs span12">
  <li><a href="../../index.html">Inicio</a></li>
  <li><a href="../index.html">Symfony 1.4, la guía definitiva</a></li>
  <li><a href="../capitulo_18.html">Capítulo 18. Rendimiento</a></li>
  <li class="current"><span>18.2.. Optimizando el modelo</span></li>
</ul>

<div class="span9">
    <h1 id="optimizando_el_modelo"><span>18.2.</span> Optimizando el modelo</h1>
    

<p>En Symfony, la capa del modelo tiene fama de ser el componente más lento. Si las pruebas de rendimiento demuestran que se debe optimizar esta capa para una aplicación, a continuación se muestran las posibles mejoras que se pueden realizar.</p>

<h3 id="optimizando_la_integracion_de_propel_o_doctrine">18.2.1. Optimizando la integración de Propel o Doctrine</h3>

<p>Inicializar la capa del modelo (las clases internas del ORM) requiere cierto tiempo, ya que se deben cargar algunas clases y se deben construir algunos objetos. No obstante, por la forma en la que Symfony integra los dos ORM, esta inicialización solamente se produce cuando una acción requiere realmente utilizar el modelo, por lo que si sucede, se realiza lo más tarde posible. Las clases del ORM se inicializan solamente cuando un objeto del modelo generado se carga automáticamente. Por tanto, las páginas que no utilizan el modelo no se ven penalizadas por la capa del modelo.</p>

<p>Si una aplicación no necesita la capa del modelo, se puede evitar la inicialización del objeto <code>sfDatabaseManager</code> desactivando por completo la capa del modelo mediante la siguiente opción del archivo <code>settings.yml</code>:</p>

<div class="code yaml">
<pre class="yaml"><span class="co4">all</span>:<span class="co4">
  .settings</span>:<span class="co3">
    use_database</span><span class="sy2">: </span>false</pre>
</div>

<h3 id="mejoras_para_propel">18.2.2. Mejoras para Propel</h3>

<p>Las clases generadas para el modelo (en <code>lib/model/om/</code>) ya están optimizadas porque se les han eliminado los comentarios y también se cargan de forma automática cuando es necesario. Utilizar el sistema de carga automática en vez de incluir las clases a mano, garantiza que las clases se cargan solamente cuando son realmente necesarias. Por tanto, si una clase del modelo no se utiliza, el mecanismo de carga automática ahorra tiempo de ejecución, mientras que la alternativa de utilizar sentencias <code>include</code> de PHP no podría ahorrarlo. En lo que respecta a los comentarios, se utilizan para documentar el uso de los métodos generados, pero aumentan mucho el tamaño de los archivos, lo que disminuye el rendimiento en los sistemas con discos duros lentos. Como los métodos de las clases generadas tienen nombres muy explícitos, los comentarios se desactivan por defecto.</p>

<p>Estas dos mejoras son específicas de Symfony, pero se puede volver a las opciones por defecto de Propel cambiando estas dos opciones en el archivo <code>propel.ini</code>, como se muestra a continuación:</p>

<div class="code yaml">
<pre class="yaml">propel.builder.addIncludes = true   <span class="co1"># Añadir sentencias &quot;include&quot; en las clases generadas</span>
                                    <span class="co1">#  en vez de utiliza la carga automática de clases</span>
propel.builder.addComments = true   <span class="co1"># Añadir comentarios a las clases generadas</span></pre>
</div>

<h4 id="limitando_el_numero_de_objetos_que_se_procesan">18.2.2.1. Limitando el número de objetos que se procesan</h4>

<p>Cuando se utiliza un método de una clase <em>peer</em> para obtener los objetos, el resultado de la consulta pasa el proceso de <em>"hidratación"</em>  <em>"hydrating"</em> en inglés) en el que se crean los objetos y se cargan con los datos de las filas devueltas en el resultado de la consulta. Para obtener por ejemplo todas las filas de la tabla <code>articulo</code> mediante Propel, se ejecuta la siguiente instrucción:</p>

<div class="code php">
<pre class="php"><span class="re0">$articulos</span> <span class="sy0">=</span> ArticuloPeer<span class="sy0">::</span><span class="me2">doSelect</span><span class="br0">&#40;</span><span class="kw2">new</span> Criteria<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>

<p>La variable <code>$articulos</code> resultante es un array con los objetos de tipo <code>Article</code>. Cada objeto se crea e inicializa, lo que requiere cierta cantidad de tiempo. La consecuencia de este comportamiento es que, al contrario de lo que sucede con las consultas a la base de datos, la velocidad de ejecución de una consulta Propel es directamente proporcional al número de resultados que devuelve. De esta forma, los métodos del modelo deberían optimizarse para devolver solamente un número limitado de resultados. Si no se necesitan todos los resultados devueltos por <code>Criteria</code>, se deberían limitar mediante los métodos <code>setLimit()</code> y <code>setOffset()</code>. Si solamente se necesitan por ejemplo las filas de datos de la 10 a la 20 para una consulta determinada, se puede refinar el objeto <code>Criteria</code> como se muestra en el listado 18-1.</p>

<p><strong>Listado 18-1 - Limitando el número de resultados devueltos por Criteria</strong></p>

<div class="code php">
<pre class="php"><span class="re0">$c</span> <span class="sy0">=</span> <span class="kw2">new</span> Criteria<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="re0">$c</span><span class="sy0">-&gt;</span><span class="me1">setOffset</span><span class="br0">&#40;</span><span class="nu0">10</span><span class="br0">&#41;</span><span class="sy0">;</span>  <span class="co1">// Posición de la primera fila que se obtiene</span>
<span class="re0">$c</span><span class="sy0">-&gt;</span><span class="me1">setLimit</span><span class="br0">&#40;</span><span class="nu0">10</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// Número de filas devueltas</span>
<span class="re0">$articulos</span> <span class="sy0">=</span> ArticuloPeer<span class="sy0">::</span><span class="me2">doSelect</span><span class="br0">&#40;</span><span class="re0">$c</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>
</div>

<p>El código anterior se puede automatizar utilizando un paginador. El objeto <code>sfPropelPager</code> gestiona de forma automática los valores <code>offset</code> y <code>limit</code> para una consulta Propel, de forma que solamente se crean los objetos mostrados en cada página.</p>

<h4 id="minimizando_el_numero_de_consultas_mediante_joins">18.2.2.2. Minimizando el número de consultas mediante Joins</h4>

<p>Mientras se desarrolla una aplicación, se debe controlar el número de consultas a la base de datos que realiza cada petición. La barra de depuración web muestra el número de consultas realizadas para cada página y al pulsar sobre el pequeño icono de una base de datos, se muestra el código SQL de las consultas realizadas. Si el número de consultas crece de forma desproporcionada, seguramente es necesario utilizar una Join.</p>

<p>Antes de explicar los métodos para Joins, se muestra lo que sucede cuando se recorre un array de objetos y se utiliza un método <em>getter</em> de Propel para obtener los detalles de la clase relacionada, como se ve en el listado 18-2. Este ejemplo supone que el esquema describe una tabla llamada <code>articulo</code> con una clave externa relacionada con la tabla <code>autor</code>.</p>

<p><strong>Listado 18-2 - Obteniendo los detalles de una clase relacionada dentro de un bucle</strong></p>

<div class="code php">
<pre class="php">// En la acción, Propel
$this-&gt;articulos = ArticuloPeer::doSelect(new Criteria());
&nbsp;
// En la acción, Doctrine
$this-&gt;articulos = Doctrine::getTable('Articulo')-&gt;findAll();
&nbsp;
// Consulta realizada en la base de datos por doSelect()
SELECT articulo.id, articulo.titulo, articulo.autor_id, ...
FROM   articulo
&nbsp;
// En la plantilla
&lt;ul&gt;
<span class="kw2">&lt;?php</span> <span class="kw1">foreach</span> <span class="br0">&#40;</span><span class="re0">$articulos</span> <span class="kw1">as</span> <span class="re0">$articulo</span><span class="br0">&#41;</span><span class="sy0">:</span> <span class="sy1">?&gt;</span>
  &lt;li&gt;<span class="kw2">&lt;?php</span> <span class="kw1">echo</span> <span class="re0">$articulo</span><span class="sy0">-&gt;</span><span class="me1">getTitulo</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">?&gt;</span>,
    escrito por <span class="kw2">&lt;?php</span> <span class="kw1">echo</span> <span class="re0">$articulo</span><span class="sy0">-&gt;</span><span class="me1">getAutor</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">-&gt;</span><span class="me1">getNombre</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">?&gt;</span>&lt;/li&gt;
<span class="kw2">&lt;?php</span> <span class="kw1">endforeach</span><span class="sy0">;</span> <span class="sy1">?&gt;</span>
&lt;/ul&gt;</pre>
</div>

<p>Si el array <code>$articulos</code> contiene 10 objetos, el método <code>getAutor()</code> se llama 10 veces, lo que implica una consulta con la base de datos cada vez que se tiene que crear un objeto de tipo <code>Autor</code>, como se muestra en el listado 18-3.</p>

<p><strong>Listado 18-3 - Los métodos <em>getter</em> de las claves externas, implican una consulta a la base de datos</strong></p>

<div class="code php">
<pre class="php"><span class="co1">// En la plantilla</span>
<span class="re0">$articulo</span><span class="sy0">-&gt;</span><span class="me1">getAutor</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
&nbsp;
<span class="co1">// Consulta a la base de datos producida por getAutor()</span>
SELECT autor<span class="sy0">.</span>id<span class="sy0">,</span> autor<span class="sy0">.</span>nombre<span class="sy0">,</span> <span class="sy0">...</span>
FROM   autor
WHERE  autor<span class="sy0">.</span>id <span class="sy0">=</span> ?                <span class="co1">// ? es articulo.autor_id</span></pre>
</div>

<p>Por tanto, la página que genera el listado 18-2 implica 11 consultas a la base de datos: una consulta para construir el array de objetos <code>Articulo</code> y otras 10 consultas para obtener el objeto <code>Autor</code> asociado a cada objeto anterior. Evidentemente, se trata de un número de consultas muy grande para mostrar simplemente un listado de los artículos disponibles y sus autores.</p>

<h3 id="optimizar_las_consultas_propel">18.2.3. Optimizar las consultas Propel</h3>

<p>Si se utiliza directamente SQL, es muy fácil reducir al mínimo el número de consultas, obteniendo las columnas de la tabla <code>articulo</code> y las de la tabla <code>autor</code> mediante una única consulta. Esto es exactamente lo que hace el método <code>doSelectJoinAutor()</code> de la clase <code>ArticuloPeer</code>. Este método realiza una consulta más compleja que un simple <code>doSelect()</code>, y las columnas adicionales que están presentes en el resultado obtenido permiten a Propel <em>"hidratar"</em> tanto los objetos de tipo <code>Articulo</code> como los objetos de tipo <code>Autor</code>. El código del listado 18-4 produce el mismo resultado que el del listado 18-2, pero solamente requiere 1 consulta con la base de datos en vez de 11 consultas, por lo que es mucho más rápido.</p>

<p><strong>Listado 18-4 - Obteniendo los detalles de los artículos y sus autores en la misma consulta</strong></p>

<div class="code php">
<pre class="php">// En la acción
$this-&gt;articulos = ArticuloPeer::doSelectJoinAutor(new Criteria());
&nbsp;
// Consulta a la base de datos realizada por doSelectJoinAutor()
SELECT articulo.id, articulo.titulo, articulo.autor_id, ...
       autor.id, autor.name, ...
FROM   articulo, autor
WHERE  articulo.autor_id = autor.id
&nbsp;
// En la plantilla no hay cambios
&lt;ul&gt;
<span class="kw2">&lt;?php</span> <span class="kw1">foreach</span> <span class="br0">&#40;</span><span class="re0">$articulos</span> <span class="kw1">as</span> <span class="re0">$articulo</span><span class="br0">&#41;</span><span class="sy0">:</span> <span class="sy1">?&gt;</span>
  &lt;li&gt;<span class="kw2">&lt;?php</span> <span class="kw1">echo</span> <span class="re0">$articulo</span><span class="sy0">-&gt;</span><span class="me1">getTitulo</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">?&gt;</span>,
    escrito por <span class="kw2">&lt;?php</span> <span class="kw1">echo</span> <span class="re0">$articulo</span><span class="sy0">-&gt;</span><span class="me1">getAutor</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">-&gt;</span><span class="me1">getNombre</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">?&gt;</span>&lt;/li&gt;
<span class="kw2">&lt;?php</span> <span class="kw1">endforeach</span><span class="sy0">;</span> <span class="sy1">?&gt;</span>
&lt;/ul&gt;</pre>
</div>

<p>No existen diferencias entre el resultado devuelto por <code>doSelect()</code> y el resultado devuelto por <code>doSelectJoinXXX()</code>; los dos métodos devuelven el mismo array de objetos (de tipo <code>Articulo</code> en este ejemplo). La diferencia se hace evidente cuando se utiliza un método <em>getter</em> asociado con una clave externa. En el caso del método <code>doSelect()</code>, se realiza una consulta a la base de datos y se crea un nuevo objeto con el resultado; en el caso del método <code>doSelectJoinXXX()</code>, el objeto asociado ya existe y no se realiza la consulta con la base de datos, por lo que el proceso es mucho más rápido. Por tanto, si se sabe de antemano que se van a utilizar los objetos relacionados, se debe utilizar el método <code>doSelectJoinXXX()</code> para reducir el número de consultas a la base de datos y por tanto, para mejorar el rendimiento de la página.</p>

<p>El método <code>doSelectJoinAutor()</code> se genera automáticamente cuando se ejecuta la tarea <code>propel-build-model</code>, debido a la relación entre las tablas <code>articulo</code> y <code>autor</code>. Si existen otras claves externas en la tabla del artículo, por ejemplo una tabla de categorías, la clase <code>BaseArticuloPeer</code> generada contendría otros métodos Join, como se muestra en el listado 18-5.</p>

<p><strong>Listado 18-5 - Ejemplo de métodos <code>doSelect</code> disponibles para una clase <code>ArticuloPeer</code></strong></p>

<div class="code php">
<pre class="php"><span class="co1">// Obtiene objetos &quot;Articulo&quot;</span>
doSelect<span class="br0">&#40;</span><span class="br0">&#41;</span>
&nbsp;
<span class="co1">// Obtiene objetos &quot;Articulo&quot; y crea los objetos &quot;Autor&quot; relacionados</span>
doSelectJoinAutor<span class="br0">&#40;</span><span class="br0">&#41;</span>
&nbsp;
<span class="co1">// Obtiene objetos &quot;Articulo&quot; y crea los objetos &quot;Categoria&quot; relacionados</span>
doSelectJoinCategoria<span class="br0">&#40;</span><span class="br0">&#41;</span>
&nbsp;
<span class="co1">// Obtiene objetos &quot;Articulo&quot; y crea todos los objetos relacionados salvo &quot;Autor&quot;</span>
doSelectJoinAllExceptAutor<span class="br0">&#40;</span><span class="br0">&#41;</span>
&nbsp;
<span class="co1">// Obtiene objetos &quot;Articulo&quot; y crea todos los objetos relacionados</span>
doSelectJoinAll<span class="br0">&#40;</span><span class="br0">&#41;</span></pre>
</div>

<p>Las clases <em>peer</em> también disponen de métodos Join para <code>doCount()</code>. Las clases que soportan la internacionalización (ver Capítulo 13) disponen de un método <code>doSelectWithI18n()</code>, que se comporta igual que los métodos Join, pero con los objetos de tipo i18n. Para descubrir todos los métodos de tipo Join generados para las clases del modelo, es conveniente inspeccionar las clases <em>peer</em> generadas en el directorio <code>lib/model/om/</code>. Si no se encuentra el método Join necesario para una consulta (por ejemplo no se crean automáticamente los métodos Join para las relaciones muchos-a-muchos), se puede crear un método propio que extienda el modelo.</p>

<div class="admonition note"><p><strong class="title">Nota</strong> Evidentemente, la llamada al método <code>doSelectJoinXXX()</code> es un poco más lenta que la llamada a un método simple <code>doSelect()</code>, por lo que solamente mejora el rendimiento global de la página si se utilizan los objetos relacionados.</p></div>

<h3 id="optimizar_las_consultas_doctrine">18.2.4. Optimizar las consultas Doctrine</h3>

<p>Doctrine define su propio lenguaje para consultas llamado DQL o <em>Doctrine Query Language</em>. Su sintaxis es muy similar a la de SQL, pero se emplea para obtener objetos en vez de filas de tablas. Con SQL podrías obtener en una sola consulta las columnas de la tabla <code>articulo</code> y <code>autor</code>. Con DQL también resulta muy sencillo hacerlo, ya que sólo debes añadir una sentencia de tipo <code>join</code> en la consulta original. Doctrine se encarga de <em>hidratar</em> correctamente todos los objetos relacionados. El siguiente ejemplo muestra cómo realizar una unión entre dos tablas:</p>

<div class="code php">
<pre class="php">// en la acción
Doctrine::getTable('Articulo')
  -&gt;createQuery('a')
  -&gt;innerJoin('a.Autor')  // &quot;a.Autor&quot; hace referencia a la relación llamada 'Autor'
  -&gt;execute();
&nbsp;
// La plantilla no requiere cambios
&lt;ul&gt;
<span class="kw2">&lt;?php</span> <span class="kw1">foreach</span> <span class="br0">&#40;</span><span class="re0">$articulos</span> <span class="kw1">as</span> <span class="re0">$articulo</span><span class="br0">&#41;</span><span class="sy0">:</span> <span class="sy1">?&gt;</span>
  &lt;li&gt;<span class="kw2">&lt;?php</span> <span class="kw1">echo</span> <span class="re0">$articulo</span><span class="sy0">-&gt;</span><span class="me1">getTitulo</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">?&gt;</span>,
    escrito por <span class="kw2">&lt;?php</span> <span class="kw1">echo</span> <span class="re0">$articulo</span><span class="sy0">-&gt;</span><span class="me1">getAutor</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">-&gt;</span><span class="me1">getNombre</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">?&gt;</span>&lt;/li&gt;
<span class="kw2">&lt;?php</span> <span class="kw1">endforeach</span><span class="sy0">;</span> <span class="sy1">?&gt;</span>
&lt;/ul&gt;</pre>
</div>

<h3 id="evitar_el_uso_de_arrays_temporales">18.2.5. Evitar el uso de arrays temporales</h3>

<p>Cuando se utiliza Propel, los objetos creados ya contienen todos los datos, por lo que no es necesario crear un array temporal de datos para la plantilla. Los programadores que no están acostumbrados a trabajar con ORM suelen caer en este error. Estos programadores suelen preparar un array de cadenas de texto o de números para las plantillas, mientras que, en realidad, las plantillas pueden trabajar directamente con los arrays de objetos. Si la plantilla por ejemplo muestra la lista de títulos de todos los artículos de la base de datos, un programador que no está acostumbrado a trabajar de esta forma puede crear un código similar al del listado 18-6.</p>

<p><strong>Listado 18-6 - Crear un array temporal en la acción es inútil si ya se dispone de un array de objetos</strong></p>

<div class="code php">
<pre class="php">// En la acción
$articulos = ArticuloPeer::doSelect(new Criteria());
$titulos = array();
foreach ($articulos as $articulo)
{
  $titulos[] = $articulo-&gt;getTitulo();
}
$this-&gt;titulos = $titulos;
&nbsp;
// En la plantilla
&lt;ul&gt;
<span class="kw2">&lt;?php</span> <span class="kw1">foreach</span> <span class="br0">&#40;</span><span class="re0">$titulos</span> <span class="kw1">as</span> <span class="re0">$titulo</span><span class="br0">&#41;</span><span class="sy0">:</span> <span class="sy1">?&gt;</span>
  &lt;li&gt;<span class="kw2">&lt;?php</span> <span class="kw1">echo</span> <span class="re0">$titulo</span> <span class="sy1">?&gt;</span>&lt;/li&gt;
<span class="kw2">&lt;?php</span> <span class="kw1">endforeach</span><span class="sy0">;</span> <span class="sy1">?&gt;</span>
&lt;/ul&gt;</pre>
</div>

<p>El problema del código anterior es que el proceso de creación de objetos del método <code>doSelect()</code> hace que crear el array <code>$titulos</code> sea inútil, ya que el mismo código se puede reescribir como muestra el listado 18-7. De esta forma, el tiempo que se pierde creando el array <code>$titulos</code> se puede aprovechar para mejorar el rendimiento de la aplicación.</p>

<p><strong>Listado 18-7 - Utilizando el array de objetos, no es necesario crear un array temporal</strong></p>

<div class="code php">
<pre class="php">// En la acción, con Propel
$this-&gt;articulos = ArticuloPeer::doSelect(new Criteria());
&nbsp;
// En la acción, con Doctrine
$this-&gt;articulos = Doctrine::getTable('Articulo')-&gt;findAll();
&nbsp;
// En la plantilla
&lt;ul&gt;
<span class="kw2">&lt;?php</span> <span class="kw1">foreach</span> <span class="br0">&#40;</span><span class="re0">$articulos</span> <span class="kw1">as</span> <span class="re0">$articulo</span><span class="br0">&#41;</span><span class="sy0">:</span> <span class="sy1">?&gt;</span>
  &lt;li&gt;<span class="kw2">&lt;?php</span> <span class="kw1">echo</span> <span class="re0">$articulo</span><span class="sy0">-&gt;</span><span class="me1">getTitulo</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy1">?&gt;</span>&lt;/li&gt;
<span class="kw2">&lt;?php</span> <span class="kw1">endforeach</span><span class="sy0">;</span> <span class="sy1">?&gt;</span>
&lt;/ul&gt;</pre>
</div>

<p>Si realmente es necesario crear un array temporal porque se realiza cierto procesamiento con los objetos, la mejor solución es la de crear un nuevo método en la clase del modelo que devuelva directamente ese array. Si por ejemplo se necesita un array con los títulos de los artículos y el número de comentarios de cada artículo, la acción y la plantilla deberían ser similares a las del listado 18-8.</p>

<p><strong>Listado 18-8 - Creando un método propio para preparar un array temporal</strong></p>

<div class="code php">
<pre class="php">// En la acción
$this-&gt;articulos = ArticuloPeer::getArticuloTitulosConNumeroComentarios();
&nbsp;
// En la plantilla
&lt;ul&gt;
<span class="kw2">&lt;?php</span> <span class="kw1">foreach</span> <span class="br0">&#40;</span><span class="re0">$articulos</span> <span class="kw1">as</span> <span class="re0">$articulo</span><span class="br0">&#41;</span><span class="sy0">:</span> <span class="sy1">?&gt;</span>
  &lt;li&gt;<span class="kw2">&lt;?php</span> <span class="kw1">echo</span> <span class="re0">$articulo</span><span class="br0">&#91;</span><span class="st_h">'titulo'</span><span class="br0">&#93;</span> <span class="sy1">?&gt;</span> (<span class="kw2">&lt;?php</span> <span class="kw1">echo</span> <span class="re0">$articulo</span><span class="br0">&#91;</span><span class="st_h">'numero_comentarios'</span><span class="br0">&#93;</span> <span class="sy1">?&gt;</span> comentarios)&lt;/li&gt;
<span class="kw2">&lt;?php</span> <span class="kw1">endforeach</span><span class="sy0">;</span> <span class="sy1">?&gt;</span>
&lt;/ul&gt;</pre>
</div>

<p>Solamente falta crear un método <code>getArticuloTitulosConNumeroComentarios()</code> muy rápido en el modelo, que se puede crear saltándose por completo el ORM y todas las capas de abstracción de bases de datos.</p>

<h3 id="saltandose_el_orm">18.2.6. Saltándose el ORM</h3>

<p>Cuando no se quieren utilizar los objetos completos, sino que solamente son necesarias algunas columnas de cada tabla (como en el ejemplo anterior) se pueden crear métodos específicos en el modelo que se salten por completo la capa del ORM. Se puede utilizar por ejemplo PDO para acceder directamente a la base de datos y devolver un array con un formato propio, como se muestra en el listado 18-9.</p>

<p><strong>Listado 18-9 - Accediendo directamente con PDO para optimizar los métodos del modelo, en <code>lib/model/ArticuloPeer.php</code></strong></p>

<div class="code php">
<pre class="php"><span class="co1">// Con Propel</span>
<span class="kw2">class</span> ArticuloPeer <span class="kw2">extends</span> BaseArticuloPeer
<span class="br0">&#123;</span>
  <span class="kw2">public</span> static <span class="kw2">function</span> getArticuloTitulosConNumeroComentarios<span class="br0">&#40;</span><span class="br0">&#41;</span>
  <span class="br0">&#123;</span>
    <span class="re0">$conexion</span> <span class="sy0">=</span> Propel<span class="sy0">::</span><span class="me2">getConnection</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="re0">$consulta</span> <span class="sy0">=</span> <span class="st_h">'SELECT %s as titulo, COUNT(%s) AS numero_comentarios FROM %s LEFT JOIN %s ON %s = %s GROUP BY %s'</span><span class="sy0">;</span>
    <span class="re0">$consulta</span> <span class="sy0">=</span> <span class="kw3">sprintf</span><span class="br0">&#40;</span><span class="re0">$consulta</span><span class="sy0">,</span>
      ArticuloPeer<span class="sy0">::</span><span class="me2">TITULO</span><span class="sy0">,</span> ComentarioPeer<span class="sy0">::</span><span class="me2">ID</span><span class="sy0">,</span>
      ArticuloPeer<span class="sy0">::</span><span class="me2">TABLE_NAME</span><span class="sy0">,</span> ComentarioPeer<span class="sy0">::</span><span class="me2">TABLE_NAME</span><span class="sy0">,</span>
      ArticuloPeer<span class="sy0">::</span><span class="me2">ID</span><span class="sy0">,</span> ComentarioPeer<span class="sy0">::</span><span class="me2">ARTICULO_ID</span><span class="sy0">,</span>
      ArticuloPeer<span class="sy0">::</span><span class="me2">ID</span>
    <span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="re0">$sentencia</span> <span class="sy0">=</span> <span class="re0">$conexion</span><span class="sy0">-&gt;</span><span class="me1">prepare</span><span class="br0">&#40;</span><span class="re0">$consulta</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="re0">$sentencia</span><span class="sy0">-&gt;</span><span class="me1">execute</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="re0">$resultados</span> <span class="sy0">=</span> <span class="kw3">array</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw1">while</span> <span class="br0">&#40;</span><span class="re0">$resultset</span> <span class="sy0">=</span> <span class="re0">$sentencia</span><span class="sy0">-&gt;</span><span class="me1">fetch</span><span class="br0">&#40;</span>PDO<span class="sy0">::</span><span class="me2">FETCH_OBJ</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
      <span class="re0">$resultados</span><span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="kw3">array</span><span class="br0">&#40;</span><span class="st_h">'titulo'</span> <span class="sy0">=&gt;</span> <span class="re0">$resultset</span><span class="sy0">-&gt;</span><span class="me1">titulo</span><span class="sy0">,</span> <span class="st_h">'numero_comentarios'</span> <span class="sy0">=&gt;</span> <span class="re0">$resultset</span><span class="sy0">-&gt;</span><span class="me1">numero_comentarios</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">return</span> <span class="re0">$resultados</span><span class="sy0">;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="co1">// Con Doctrine</span>
<span class="kw2">class</span> ArticuloTable <span class="kw2">extends</span> Doctrine_Table
<span class="br0">&#123;</span>
  <span class="kw2">public</span> <span class="kw2">function</span> getArticuloTitulosConNumeroComentarios<span class="br0">&#40;</span><span class="br0">&#41;</span>
  <span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="re0">$this</span><span class="sy0">-&gt;</span><span class="me1">createQuery</span><span class="br0">&#40;</span><span class="st_h">'a'</span><span class="br0">&#41;</span>
        <span class="sy0">-&gt;</span><span class="me1">select</span><span class="br0">&#40;</span><span class="st_h">'a.titulo, count(*) as numero_comentarios'</span><span class="br0">&#41;</span>
        <span class="sy0">-&gt;</span><span class="me1">leftJoin</span><span class="br0">&#40;</span><span class="st_h">'a.Comentarios'</span><span class="br0">&#41;</span>
        <span class="sy0">-&gt;</span><span class="me1">groupBy</span><span class="br0">&#40;</span><span class="st_h">'a.id'</span><span class="br0">&#41;</span>
        <span class="sy0">-&gt;</span><span class="me1">fetchArray</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
</div>

<p>Si se crean muchos métodos de este tipo, se puede acabar creando un método específico para cada acción, perdiendo la ventaja de la separación en capas y la abstracción de la base de datos.</p>

<h3 id="optimizando_la_base_de_datos">18.2.7. Optimizando la base de datos</h3>

<p>Existen numerosas técnicas para optimizar la base de datos y que pueden ser aplicadas independientemente de Symfony. En esta sección, se repasan brevemente algunas de las estrategias más utilizadas, aunque es necesario un buen conocimiento de motores de bases de datos para optimizar la capa del modelo.</p>

<div class="admonition note"><p><strong class="title">Nota</strong> Recuerda que la barra de depuración web muestra el tiempo de ejecución de cada consulta realizada por la página, por lo que cada cambio que se realice debería comprobarse para ver si realmente reduce el tiempo de ejecución.</p></div>

<p>A menudo, las consultas a las bases de datos se realizan sobre columnas que no son claves primarias. Para aumentar la velocidad de ejecución de esas consultas, se deben crear índices en el esquema de la base de datos. Para añadir un índice a una columna, se añade la propiedad <code>index: true</code> a la definición de la columna, tal y como muestra el listado 18-10.</p>

<p><strong>Listado 18-10 - Añadiendo un índice a una sola columna, en <code>config/schema.yml</code></strong></p>

<div class="code yaml">
<pre class="yaml"><span class="co1"># Esquema de Propel</span><span class="co4">
propel</span>:<span class="co4">
  articulo</span>:<span class="co4">
    id</span>:<span class="co4">
    autor_id</span>:<span class="co3">
    titulo</span><span class="sy2">: </span>  <span class="br0">&#123;</span> type<span class="sy2">: </span>varchar<span class="br0">&#40;</span><span class="nu0">100</span><span class="br0">&#41;</span>, index<span class="sy2">: </span>true <span class="br0">&#125;</span>
&nbsp;
<span class="co1"># Esquema de Doctrine</span><span class="co4">
Articulo</span>:<span class="co4">
  columns</span>:<span class="co3">
    autor_id</span><span class="sy2">: </span>integer<span class="co3">
    titulo</span><span class="sy2">: </span>  string<span class="br0">&#40;</span><span class="nu0">100</span><span class="br0">&#41;</span><span class="co4">
  indexes</span>:<span class="co4">
    titulo</span>:<span class="co3">
      fields</span><span class="sy2">: </span><span class="br0">&#91;</span>titulo<span class="br0">&#93;</span></pre>
</div>

<p>Se puede utilizar de forma alternativa el valor <code>index: unique</code> para definir un índice único en vez de un índice normal. El archivo <code>schema.yml</code> también permite definir índices sobre varias columnas (el Capítulo 8 contiene más información sobre la sintaxis de los índices). El uso de índices es muy recomendable, ya que es una buena forma de acelerar las consultas más complejas.</p>

<p>Después de añadir el índice al esquema, se debe añadir a la propia base de datos: directamente mediante una sentencia de tipo <code>ADD INDEX</code> o mediante el comando <code>propel-build-all</code> (que no solamente reconstruye la estructura de la tabla, sino que borra todos los datos existentes).</p>

<div class="admonition note"><p><strong class="title">Nota</strong> Las consultas de tipo <code>SELECT</code> son más rápidas cuando se utilizan índices, pero las sentencias de tipo <code>INSERT</code>, <code>UPDATE</code> y <code>DELETE</code> son más lentas. Además, los motores de bases de datos solamente utilizan 1 índice en cada consulta y determinan el índice a utilizar en cada consulta mediante métodos heurísticos internos. Por tanto, se deben medir las mejoras producidas por la creación de los índices, ya que en ocasiones las mejoras producidas en el rendimiento son muy escasas.</p></div>

<p>A menos que se especifique lo contrario, en Symfony cada petición utiliza una conexión con la base de datos y esa conexión se cierra al finalizar la petición. Se pueden habilitar conexiones persistentes con la base de datos, de forma que se cree un <em>pool</em> de conexiones abiertas con la base de datos y se reutilicen en las diferentes peticiones. La opción que se debe utilizar es <code>persistent: true</code> en el archivo <code>databases.yml</code>, como muestra el listado 18-11.</p>

<p><strong>Listado 18-11 - Activar las conexiones persistentes con la base de datos, en <code>config/databases.yml</code></strong></p>

<div class="code yaml">
<pre class="yaml"><span class="co4">prod</span>:<span class="co4">
  propel</span>:<span class="co3">
    class</span><span class="sy2">: </span>        sfPropelDatabase<span class="co4">
    param</span>:<span class="co3">
      dsn</span><span class="sy2">: </span>        mysql:dbname=example;host=localhost<span class="co3">
      username</span><span class="sy2">: </span>   username<span class="co3">
      password</span><span class="sy2">: </span>   password<span class="co3">
      persistent</span><span class="sy2">: </span> true      <span class="co1"># Use persistent connections</span></pre>
</div>

<p>Esta opción puede mejorar el rendimiento de la base de datos o puede no hacerlo, dependiendo de numerosos factores. En Internet existe mucha documentación sobre las posibles mejoras que produce. Por tanto, es conveniente hacer pruebas de rendimiento sobre la aplicación antes y después de modificar el valor de esta opción.</p>

<div class="admonition sidebar"><p><strong class="title">Consejos específicos para MySQL</strong> Muchas de las opciones de configuración de MySQL, que se encuentran en el archivo <code>my.cnf</code>, pueden modificar el rendimiento de la base de datos, tal y como se explica en <a href="http://dev.mysql.com/doc/refman/5.0/en/option-files.html">su documentación</a>.</p>

<p>Una de las herramientas disponibles en MySQL es el archivo de log de las consultas lentas. Todas las consultas que tardan más de <code>long_query_time</code> segundos en ejecutarse (esta opción se modifica en el archivo <code>my.cnf</code>) se guardan en un archivo de log que es difícil de analizar manualmente, pero que el comando <code>mysqldumpslow</code> resume de forma muy útil. Se trata de una herramienta excelente para detectar las consultas que requieren ser optimizadas.</p></div>



    <div class="navigation row">
            <a class="span4 prev" href="optimizando_el_servidor.html">&larr; Anterior <span>18.1. Optimizando el servidor</span></a>
            
            <a class="span5 next" href="optimizando_la_vista.html">Siguiente &rarr; <span>18.3. Optimizando la vista</span></a>
        </div>
</div>

<div class="span3 side">
<h3 class="underline"><span>Compartir</span></h3>
<ul class="share">
    <li><a class="twitter" id="share_twitter" href="#" title="Compartir este artículo en Twitter">tw</a></li>
    <li><a class="facebook" id="share_facebook" href="#" title="Compartir este artículo en Facebook">fb</a></li>
    <li><a class="google" id="share_google" href="#" title="Compartir este artículo en Google+">g+</a></li>
</ul>

<script type="text/javascript">
var title    = 'Optimizando el modelo (Symfony 1.4, la guía definitiva%29';
var page_url = encodeURIComponent(window.location);
var options  = 'menubar=no,toolbar=no,resizable=yes,scrollbars=no,width=640,height=350';
var services = {
    share_twitter:  'https://twitter.com/share?text=' + title + '&lang=es&hashtags=librosweb',
    share_facebook: 'http://www.facebook.com/sharer.php?u=' + page_url + '&t=' + title,
    share_google:   'https://plus.google.com/share?url=' + page_url + '&hl=es'
};

for (var id in services) { // don't use services.keys() for compatibility reasons
    if (services.hasOwnProperty(id)) {
        document.getElementById(id).href = services[id];
        document.getElementById(id).onclick = function(a) {
            a = a || window.event;
            a = a.target || a.srcElement;
            _gaq.push(['_trackEvent', 'share', a.id.substr(6), 'Symfony 1.4, la guía definitiva : Optimizando el modelo']);
            window.open(services[a.id], a.title, options);

            return false;
        };
    }
}
</script>

<h3 class="underline"><span>Indice de contenidos</span></h3>
<ul class="toc">
    <li class="level-1">
        <span>1</span> <a href="../capitulo_1.html"> Introducción a Symfony</a>
    </li>
    <li class="level-1">
        <span>2</span> <a href="../capitulo_2.html"> Explorando el interior de Symfony</a>
    </li>
    <li class="level-1">
        <span>3</span> <a href="../capitulo_3.html"> Ejecutar aplicaciones Symfony</a>
    </li>
    <li class="level-1">
        <span>4</span> <a href="../capitulo_4.html"> Introducción a la creación de páginas</a>
    </li>
    <li class="level-1">
        <span>5</span> <a href="../capitulo_5.html"> Configurar Symfony</a>
    </li>
    <li class="level-1">
        <span>6</span> <a href="../capitulo_6.html"> El Controlador</a>
    </li>
    <li class="level-1">
        <span>7</span> <a href="../capitulo_7.html"> La Vista</a>
    </li>
    <li class="level-1">
        <span>8</span> <a href="../capitulo_8.html"> El modelo (Doctrine)</a>
    </li>
    <li class="level-1">
        <span>9</span> <a href="../capitulo_9.html"> Enlaces y sistema de enrutamiento</a>
    </li>
    <li class="level-1">
        <span>10</span> <a href="../capitulo_10.html"> Formularios</a>
    </li>
    <li class="level-1">
        <span>11</span> <a href="../capitulo_11.html"> Emails</a>
    </li>
    <li class="level-1">
        <span>12</span> <a href="../capitulo_12.html"> Uso de la cache</a>
    </li>
    <li class="level-1">
        <span>13</span> <a href="../capitulo_13.html"> Internacionalización y localización</a>
    </li>
    <li class="level-1">
        <span>14</span> <a href="../capitulo_14.html"> Generador de la parte de administración</a>
    </li>
    <li class="level-1">
        <span>15</span> <a href="../capitulo_15.html"> Pruebas unitarias y funcionales</a>
    </li>
    <li class="level-1">
        <span>16</span> <a href="../capitulo_16.html"> Herramientas para la administración de aplicaciones</a>
    </li>
    <li class="level-1">
        <span>17</span> <a href="../capitulo_17.html"> Personalizar Symfony</a>
    </li>
    <li class="level-1 ">
        <a href="../capitulo_18.html">
            <span>Capítulo 18.</span> Rendimiento
        </a>
    </li>
    <li class="level-2 ">
        <a href="optimizando_el_servidor.html">
            <span>18.1.</span> Optimizando el servidor
        </a>
    </li>
    <li class="level-2 active">
        <a href="optimizando_el_modelo.html">
            <span>18.2.</span> Optimizando el modelo
        </a>
    </li>
    <li class="level-2 ">
        <a href="optimizando_la_vista.html">
            <span>18.3.</span> Optimizando la vista
        </a>
    </li>
    <li class="level-2 ">
        <a href="optimizando_la_cache.html">
            <span>18.4.</span> Optimizando la cache
        </a>
    </li>
    <li class="level-2 ">
        <a href="desactivando_las_caracteristicas_que_no_se_utilizan.html">
            <span>18.5.</span> Desactivando las características que no se utilizan
        </a>
    </li>
    <li class="level-2 ">
        <a href="optimizando_el_codigo_fuente.html">
            <span>18.6.</span> Optimizando el código fuente
        </a>
    </li>
    <li class="level-2 ">
        <a href="resumen.html">
            <span>18.7.</span> Resumen
        </a>
    </li>
    <li class="level-1">
        <span>19</span> <a href="../capitulo_19.html"> Configuración avanzada</a>
    </li>
</ul>
</div>
        </div></div>
        <div id="footer" class="row">
            <span class="span6">&copy; 2013 LibrosWeb.es 
            <a href="../../contacto/index.html">Contacto</a></span>
            <span class="span6 version">2.340 días online</span>
        </div>
    </div>
    </body>
</html>

<!-- Localized -->